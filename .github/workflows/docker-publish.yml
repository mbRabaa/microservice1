name: CI/CD - Pipeline DevOps avec Terraform et Kubernetes +monitoring 
# Nom de votre workflow qui appara√Ætra dans l'interface GitHub Actions

on:
  push:
    branches:
      - main
# D√©clenche le workflow √† chaque push sur la branche main

env:
  # Section des variables d'environnement globales
  # Configuration Kubernetes
  K3S_VERSION: v1.26.5+k3s1  # Version de K3s √† installer
  NAMESPACE: microservice     # Namespace Kubernetes √† utiliser
  DOCKER_REGISTRY: docker.io  # Registry Docker utilis√©e
  
  # Configuration Application
  APP_NAME: gestion-trajet            # Nom de l'application
  DEPLOYMENT_NAME: gestion-trajet-deployment  # Nom du d√©ploiement Kubernetes
  SERVICE_NAME: gestion-trajet-service        # Nom du service Kubernetes
  CONTAINER_PORT: 80                 # Port expos√© par le container
  SERVICE_PORT: 80                   # Port expos√© par le service
  
  # Configuration Terraform
  TERRAFORM_VERSION: 1.5.5           # Version de Terraform √† utiliser
  TF_VAR_replica_count: 3            # Nombre de r√©plicas pour le d√©ploiement
  
  # Configuration Monitoring
  PROMETHEUS_PORT: 9090      # Port pour Prometheus
  GRAFANA_PORT: 3000         # Port pour Grafana
  GRAFANA_ADMIN_PASSWORD: rabaa123  # Mot de passe admin Grafana
  
  # Configuration SonarQube
  SONAR_HOST_URL: http://localhost:9000  # URL pour SonarQube
  
  # Configuration Email
  YOUR_EMAIL: elmbarkirabea@gmail.com    # Email pour les notifications
  EMAIL_FROM: "GitHub Actions <actions@github.com>"  # Exp√©diteur des emails

jobs:
  # Premier job : Installation et tests
  setup-and-test:
    name: "1. Installation et Tests"
    runs-on: ubuntu-latest  # Ex√©cut√© sur une machine Ubuntu
    
    steps:
      # √âtape 1: R√©cup√©ration du code source
      - name: "üõéÔ∏è Checkout du code"
        uses: actions/checkout@v4.1.1  # Action officielle pour checkout le code

      # √âtape 2: Configuration de Node.js
      - name: "‚éî Configurer Node.js"
        uses: actions/setup-node@v3
        with:
          node-version: 20  # Version de Node.js
          cache: 'npm'      # Active le cache npm pour acc√©l√©rer les builds

      # √âtape 3: Installation des d√©pendances
      - name: "üì¶ Installer les d√©pendances"
        run: npm ci  # Installation pr√©cise des d√©pendances (comme package-lock.json)

      # √âtape 4: Ex√©cution des tests unitaires
      - name: "üß™ Tests Unitaires"
        run: npm run test:unit
        env:
          NODE_ENV: test  # D√©finit l'environnement comme "test"

      # √âtape 5: Ex√©cution des tests d'int√©gration
      - name: "üîó Tests d'Int√©gration"
        run: npm run test:integration
        env:
          DB_HOST: localhost  # Configuration de la base de donn√©es de test
          DB_PORT: 5432
          DB_USER: testuser
          DB_PASSWORD: testpass
          NODE_ENV: test

      # √âtape 6: Build de l'application
      - name: "üõ†Ô∏è Build de l'application"
        run: npm run build  # Compilation de l'application

  # Deuxi√®me job : Analyse de code avec SonarQube
  sonarqube-analysis:
    name: "2. Analyse SonarQube"
    needs: setup-and-test  # D√©pend du job setup-and-test
    runs-on: ubuntu-latest
    timeout-minutes: 30  # Timeout apr√®s 30 minutes
    
    steps:
      # √âtape 1: Checkout du code
      - name: "üõéÔ∏è Checkout du code"
        uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0  # R√©cup√®re tout l'historique git (n√©cessaire pour SonarQube)

      # √âtape 2: D√©marrage du conteneur SonarQube
      - name: "üê≥ D√©marrer SonarQube"
        run: |
          docker run -d \
            --name sonarqube \
            -p 9000:9000 \
            -e SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true \
            sonarqube:9.9.1-community
          # Attente que SonarQube soit pr√™t
          timeout 300 bash -c 'while ! curl -sSf ${{ env.SONAR_HOST_URL }}/api/system/status | grep -q "\"status\":\"UP\""; do
            sleep 10
            echo "En attente du d√©marrage..."
          done'

      # √âtape 3: G√©n√©ration du token SonarQube
      - name: "üîë G√©n√©rer token SonarQube"
        run: |
          SONAR_TOKEN=$(curl -sS -u admin:admin \
            -X POST "${{ env.SONAR_HOST_URL }}/api/user_tokens/generate" \
            -d "name=github-action-$(date +%s)" \
            | jq -r '.token')
          echo "SONAR_TOKEN=$SONAR_TOKEN" >> $GITHUB_ENV
          echo "::add-mask::$SONAR_TOKEN"  # Masque le token dans les logs

      # √âtape 4: Ex√©cution de l'analyse SonarQube
      - name: "üîç Ex√©cuter analyse SonarQube"
        uses: SonarSource/sonarqube-scan-action@v4
        env:
          SONAR_TOKEN: ${{ env.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ env.SONAR_HOST_URL }}
        with:
          args: >
            -Dsonar.projectKey=gestion-trajet-app
            -Dsonar.sources=src
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info

      # √âtape 5: Nettoyage (toujours ex√©cut√©e m√™me en cas d'√©chec)
      - name: "üßπ Nettoyer SonarQube"
        if: always()
        run: docker rm -f sonarqube || true  # Supprime le conteneur SonarQube

  # Troisi√®me job : D√©ploiement Docker et Kubernetes
  docker-deploy:
    name: "3. D√©ploiement Docker et Kubernetes"
    needs: sonarqube-analysis  # D√©pend du job sonarqube-analysis
    runs-on: ubuntu-latest
    
    steps:
      # √âtape 1: Checkout du code
      - name: "üõéÔ∏è Checkout du code"
        uses: actions/checkout@v4.1.1

      # √âtape 2: Authentification √† Docker Hub
      - name: "üîê Login Docker Hub"
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}  # Utilise un secret GitHub
          password: ${{ secrets.DOCKER_TOKEN }}

      # √âtape 3: Build et push de l'image Docker
      - name: "üèóÔ∏è Build Docker"
        uses: docker/build-push-action@v4
        with:
          context: .  # R√©pertoire de build
          push: true  # Push l'image apr√®s le build
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.APP_NAME }}:${{ github.sha }}
            ${{ env.DOCKER_REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.APP_NAME }}:latest

      # √âtape 4: Installation de K3s (Kubernetes l√©ger)
      - name: "üñ•Ô∏è Installer K3s"
        run: |
          curl -sfL https://get.k3s.io | INSTALL_K3S_VERSION=${{ env.K3S_VERSION }} sh -
          sudo chmod 644 /etc/rancher/k3s/k3s.yaml  # Ajuste les permissions

      # √âtape 5: Configuration de kubectl
      - name: "‚öôÔ∏è Configurer kubectl"
        run: |
          mkdir -p $HOME/.kube
          sudo cp /etc/rancher/k3s/k3s.yaml $HOME/.kube/config
          sudo chown $(id -u):$(id -g) $HOME/.kube/config

      # √âtape 6: Nettoyage avant Terraform
      - name: "üßπ Nettoyer avant Terraform"
        run: |
          # Supprime les ressources existantes pour √©viter les conflits
          kubectl delete deployment ${{ env.DEPLOYMENT_NAME }} -n ${{ env.NAMESPACE }} --ignore-not-found=true
          kubectl delete service ${{ env.SERVICE_NAME }} -n ${{ env.NAMESPACE }} --ignore-not-found=true
          kubectl delete configmap app-config -n ${{ env.NAMESPACE }} --ignore-not-found=true
          kubectl delete secret database-credentials -n ${{ env.NAMESPACE }} --ignore-not-found=true

      # √âtape 7: Installation de Terraform
      - name: "‚öôÔ∏è Installer Terraform"
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      # √âtape 8: D√©ploiement avec Terraform
      - name: "üöÄ D√©ployer avec Terraform"
        working-directory: ./infra  # Ex√©cute dans le dossier infra
        env:
          TF_VAR_docker_username: ${{ secrets.DOCKER_USERNAME }}
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
          TF_VAR_image_tag: ${{ github.sha }}
        run: |
          terraform init    # Initialise Terraform
          terraform validate  # Valide la configuration
          # Importe le namespace s'il existe d√©j√†
          terraform import kubernetes_namespace.microservice ${{ env.NAMESPACE }} || true
          terraform apply -auto-approve  # Applique les changements

      # √âtape 9: V√©rification du d√©ploiement
      - name: "üîç V√©rifier le d√©ploiement"
        run: |
          echo "=== Ressources d√©ploy√©es ==="
          kubectl get all -n ${{ env.NAMESPACE }}  # Liste toutes les ressources
          
          echo "=== D√©tails du d√©ploiement ==="
          kubectl describe deployment/${{ env.DEPLOYMENT_NAME }} -n ${{ env.NAMESPACE }}
          
          echo "=== Test de connectivit√© ==="
          # Port-forward temporaire pour tester le service
          kubectl port-forward svc/${{ env.SERVICE_NAME }} ${{ env.SERVICE_PORT }}:${{ env.CONTAINER_PORT }} -n ${{ env.NAMESPACE }} >/dev/null 2>&1 &
          sleep 10  # Attente que le port-forward soit actif
          
          # Test de sant√© de l'application
          if curl -sSf http://localhost:${{ env.SERVICE_PORT }}/healthz; then
            echo "‚úÖ Application accessible"
          else
            echo "‚ùå √âchec de connexion"
            kubectl logs -l app=${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} --tail=50
            exit 1
          fi

      # √âtape 10: Rollback en cas d'√©chec
      - name: "üîÑ Rollback en cas d'√©chec"
        if: failure()  # Ex√©cut√© seulement en cas d'√©chec
        run: |
          echo "=== Lancement du rollback ==="
          kubectl rollout undo deployment/${{ env.DEPLOYMENT_NAME }} -n ${{ env.NAMESPACE }}
          echo "=== √âtat apr√®s rollback ==="
          kubectl get pods -n ${{ env.NAMESPACE }}
          exit 1

      # √âtape 11: Notification d'√©chec par email
      - name: "üìß Notification d'√©chec"
        if: failure()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          from: ${{ env.EMAIL_FROM }}
          to: ${{ env.YOUR_EMAIL }}
          subject: "√âchec de d√©ploiement - ${{ env.APP_NAME }}"
          body: |
            Le d√©ploiement a √©chou√©.
            
            D√©tails:
            - Commit: ${{ github.sha }}
            - Application: ${{ env.APP_NAME }}
            - Namespace: ${{ env.NAMESPACE }}
            - Heure: $(date)
            
            Un rollback a √©t√© effectu√©.

  # Quatri√®me job : D√©ploiement du monitoring
  monitoring-deploy:
    name: "4. D√©ploiement Monitoring"
    needs: docker-deploy  # D√©pend du job docker-deploy
    runs-on: ubuntu-latest
    timeout-minutes: 30  # Timeout apr√®s 30 minutes
    
    steps:
      # √âtape 1: Checkout du code
      - name: "üõéÔ∏è Checkout du code"
        uses: actions/checkout@v4.1.1
    
      # √âtape 2: Installation de Docker Compose
      - name: "üì¶ Installer Docker Compose"
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose --version

      # √âtape 3: Nettoyage de l'environnement
      - name: "üßπ Nettoyer l'environnement"
        working-directory: ./monitoring
        run: |
          docker-compose down -v --remove-orphans || true  # Arr√™te les conteneurs existants
          sudo rm -rf grafana-storage || true  # Nettoie le stockage Grafana
          mkdir -p grafana-storage
          chmod -R 777 grafana-storage  # Assure les permissions n√©cessaires

      # √âtape 4: D√©marrage des services de monitoring
      - name: "üöÄ D√©marrer les services"
        working-directory: ./monitoring
        env:
          GF_INSTALL_PLUGINS: ""  # D√©sactive les plugins par d√©faut
        run: |
          docker-compose up -d  # D√©mare les services en arri√®re-plan
          echo "Attente initiale (30s) pour l'initialisation..."
          sleep 30

      # √âtape 5: V√©rification de l'√©tat des conteneurs
      - name: "üîç V√©rifier l'√©tat des conteneurs"
        working-directory: ./monitoring
        run: |
          if docker-compose ps | grep -v "Up" | grep -q -v "STATUS"; then
            echo "‚ùå Certains services ne sont pas d√©marr√©s:"
            docker-compose ps
            docker-compose logs
            exit 1
          fi
          echo "‚úÖ Tous les services sont en cours d'ex√©cution"

      # √âtape 6: Attente que Grafana soit pr√™t (version am√©lior√©e)
      - name: "‚è≥ Attendre Grafana (version am√©lior√©e)"
        working-directory: ./monitoring
        run: |
          echo "Attente du d√©marrage de Grafana..."
          start_time=$(date +%s)
          timeout=1200  # 20 minutes max
          
          while :; do
            # V√©rifie si le conteneur Grafana est en cours d'ex√©cution
            if ! docker-compose ps | grep grafana | grep -q "Up"; then
              echo "‚ùå Le conteneur Grafana s'est arr√™t√©"
              docker-compose logs grafana
              exit 1
            fi
            
            # V√©rifie la sant√© via l'API
            if curl -s http://localhost:3000/api/health | grep -q "\"database\":\"ok\""; then
              echo "‚úÖ Grafana pr√™t apr√®s $(($(date +%s) - start_time)) secondes"
              break
            fi
            
            # V√©rifie aussi le endpoint de login
            if curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/login | grep -q 200; then
              echo "‚úÖ Grafana login page accessible apr√®s $(($(date +%s) - start_time)) secondes"
              break
            fi
            
            # Timeout apr√®s 20 minutes
            if [ $(($(date +%s) - start_time)) -ge $timeout ]; then
              echo "‚ùå Timeout - Grafana n'a pas d√©marr√© apr√®s 20 minutes"
              docker-compose logs grafana
              exit 1
            fi
            
            echo "En attente... ($(($(date +%s) - start_time))s)"
            sleep 10
          done

      # √âtape 7: Configuration de la source de donn√©es Prometheus dans Grafana
      - name: "üìà Configurer Grafana"
        working-directory: ./monitoring
        run: |
          echo "Configuration de la source de donn√©es..."
          for attempt in {1..5}; do
            response=$(curl -s -o /dev/null -w "%{http_code}" \
              -X POST "http://localhost:3000/api/datasources" \
              -H "Content-Type: application/json" \
              -u "admin:${{ env.GRAFANA_ADMIN_PASSWORD }}" \
              -d '{
                "name":"Prometheus",
                "type":"prometheus",
                "url":"http://prometheus:9090",
                "access":"proxy",
                "basicAuth":false
              }')
            
            if [ "$response" -eq 200 ]; then
              echo "‚úÖ Configuration r√©ussie"
              exit 0
            elif [ "$response" -eq 409 ]; then
              echo "‚ÑπÔ∏è La source existe d√©j√†"
              exit 0
            else
              echo "‚ö†Ô∏è √âchec tentative $attempt (HTTP $response)"
              sleep 15
            fi
          done
          echo "‚ùå √âchec apr√®s 5 tentatives"
          exit 1

      # √âtape 8: G√©n√©ration d'un rapport de monitoring
      - name: "üìù G√©n√©rer rapport"
        working-directory: ./monitoring
        run: |
          echo "# Rapport de Monitoring" > report.md
          echo "## √âtat des services" >> report.md
          docker-compose ps >> report.md
          echo "## M√©triques NGINX" >> report.md
          curl -s http://localhost:9113/metrics | head -n 20 >> report.md
          echo "## Targets Prometheus" >> report.md
          curl -s http://localhost:9090/api/v1/targets | jq . >> report.md