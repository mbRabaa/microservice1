name: CI/CD - Pipeline DevOps avec Terraform

# Déclencheur du pipeline - s'exécute lors d'un push sur la branche main
on:
  push:
    branches:
      - main

# Variables d'environnement globales
env:
  SONAR_HOST_URL: http://localhost:9000
  K3S_VERSION: v1.26.5+k3s1
  TERRAFORM_VERSION: 1.5.5
  NAMESPACE: microservice
  DOCKER_REGISTRY: docker.io
  NODE_VERSION: 20
  # URLs pour le monitoring
  PROMETHEUS_URL: http://prometheus-server.monitoring.svc.cluster.local:9090
  GRAFANA_URL: http://grafana-service.monitoring.svc.cluster.local:3000
  GRAFANA_DASHBOARD_UID: gestion-trajet-dashboard
  # Configuration email
  YOUR_EMAIL: elmbarkirabea@gmail.com
  EMAIL_FROM: "GitHub Actions <actions@github.com>"

jobs:
  # Job 1: Installation et tests de l'application
  setup-and-test:
    name: "1. Installation et Tests"
    runs-on: ubuntu-latest
    
    steps:
      # Étape 1: Récupération du code source
      - name: "🛎️ Checkout du code"
        uses: actions/checkout@v4.1.1

      # Étape 2: Configuration de Node.js
      - name: "⎔ Configurer Node.js"
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'  # Activation du cache pour npm

      # Étape 3: Installation des dépendances
      - name: "📦 Installer les dépendances"
        run: npm ci  # Installation précise des dépendances

      # Étape 4: Exécution des tests unitaires
      - name: "🧪 Tests Unitaires"
        run: npm run test:unit
        env:
          NODE_ENV: test

      # Étape 5: Exécution des tests d'intégration
      - name: "🔗 Tests d'Intégration"
        run: npm run test:integration
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: testuser
          DB_PASSWORD: testpass
          NODE_ENV: test

      # Étape 6: Build de l'application
      - name: "🛠️ Build de l'application"
        run: npm run build

  # Job 2: Analyse de code avec SonarQube
  sonarqube-analysis:
    name: "2. Analyse SonarQube"
    needs: setup-and-test  # Dépend du job setup-and-test
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: "🛎️ Checkout du code"
        uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0  # Récupère tout l'historique Git

      # Démarrage d'un conteneur SonarQube
      - name: "🐳 Démarrer SonarQube"
        run: |
          docker run -d \
            --name sonarqube \
            -p 9000:9000 \
            -e SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true \
            sonarqube:9.9.1-community
          # Attente que SonarQube soit opérationnel
          timeout 300 bash -c 'while ! curl -sSf ${{ env.SONAR_HOST_URL }}/api/system/status | grep -q "\"status\":\"UP\""; do
            sleep 10
            echo "En attente du démarrage..."
          done'

      # Génération d'un token pour l'API SonarQube
      - name: "🔑 Générer token SonarQube"
        run: |
          SONAR_TOKEN=$(curl -sS -u admin:admin \
            -X POST "${{ env.SONAR_HOST_URL }}/api/user_tokens/generate" \
            -d "name=github-action-$(date +%s)" \
            | jq -r '.token')
          echo "SONAR_TOKEN=$SONAR_TOKEN" >> $GITHUB_ENV
          echo "::add-mask::$SONAR_TOKEN"  # Masque le token dans les logs

      # Exécution de l'analyse SonarQube
      - name: "🔍 Exécuter analyse SonarQube"
        uses: SonarSource/sonarqube-scan-action@v4
        env:
          SONAR_TOKEN: ${{ env.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ env.SONAR_HOST_URL }}
        with:
          args: >
            -Dsonar.projectKey=gestion-trajet-app
            -Dsonar.sources=src
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info

      # Nettoyage du conteneur SonarQube
      - name: "🧹 Nettoyer SonarQube"
        if: always()  # S'exécute même en cas d'échec
        run: docker rm -f sonarqube || true

  # Job 3: Déploiement Docker et Kubernetes
  docker-deploy:
    name: "3. Déploiement Docker et Kubernetes"
    needs: sonarqube-analysis
    runs-on: ubuntu-latest
    
    steps:
      - name: "🛎️ Checkout du code"
        uses: actions/checkout@v4.1.1

      # Authentification à Docker Hub
      - name: "🔐 Login Docker Hub"
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      # Construction et push de l'image Docker
      - name: "🏗️ Build Docker"
        uses: docker/build-push-action@v4
        with:
          context: .  # Répertoire de construction
          push: true  # Push automatique après build
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/gestion-trajet:${{ github.sha }}
            ${{ env.DOCKER_REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/gestion-trajet:latest

      # Installation de K3s (Kubernetes léger)
      - name: "🖥️ Installer K3s"
        run: |
          curl -sfL https://get.k3s.io | INSTALL_K3S_VERSION=${{ env.K3S_VERSION }} sh -
          sudo chmod 644 /etc/rancher/k3s/k3s.yaml  # Ajustement des permissions

      # Configuration de kubectl
      - name: "⚙️ Configurer kubectl"
        run: |
          mkdir -p $HOME/.kube
          sudo cp /etc/rancher/k3s/k3s.yaml $HOME/.kube/config
          sudo chown $(id -u):$(id -g) $HOME/.kube/config

      # Installation de Terraform
      - name: "⚙️ Installer Terraform"
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      # Déploiement avec Terraform
      - name: "🚀 Déployer avec Terraform"
        working-directory: ./infra  # Exécution dans le dossier infra
        env:
          TF_VAR_docker_username: ${{ secrets.DOCKER_USERNAME }}
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
          TF_VAR_image_tag: ${{ github.sha }}
        run: |
          terraform init
          terraform validate
          terraform apply -auto-approve

      # Vérification du déploiement
      - name: "🔍 Vérifier le déploiement"
        run: |
          kubectl get pods,svc,deploy -n ${{ env.NAMESPACE }}
          echo "Service URL: $(terraform -chdir=infra output -raw service_url)"

  # Job 4: Déploiement et vérification du monitoring
  monitoring-deploy:
    name: "4. Déploiement et Vérification Monitoring"
    needs: docker-deploy
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    steps:
      - name: "🛎️ Checkout du code"
        uses: actions/checkout@v4.1.1

      # Installation de Docker Compose (nécessaire pour la stack monitoring)
      - name: "📦 Installer Docker Compose"
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose --version

      # Déploiement de la stack monitoring
      - name: "📦 Déployer la stack monitoring"
        working-directory: ./monitoring
        run: |
          # Vérifie si la stack est déjà déployée
          if docker-compose ps | grep -q "Up"; then
            echo "La stack monitoring est déjà en cours d'exécution"
            docker-compose ps
          else
            echo "Démarrage de la stack monitoring..."
            docker-compose up -d
          fi

          # Attente que les services soient prêts
          echo "⏳ Attente du démarrage des services..."
          timeout 120 bash -c 'until docker-compose ps | grep -q "Up (healthy)"; do
            sleep 5
            echo "En attente..."
          done' || echo "Certains services ne sont pas healthy"

      # Vérification de l'état des services
      - name: "🔍 Vérifier l'état des services"
        working-directory: ./monitoring
        run: |
          echo "=== État des conteneurs ==="
          docker-compose ps

          echo "=== Logs des services ==="
          docker-compose logs --tail=50 || true

      # Vérification de Prometheus
      - name: "📊 Vérifier Prometheus"
        run: |
          PROMETHEUS_LOCAL="http://localhost:9090"
          echo "Vérification de Prometheus sur $PROMETHEUS_LOCAL"

          # Attente que Prometheus soit prêt
          timeout 60 bash -c 'until curl -sSf "$PROMETHEUS_LOCAL/-/ready"; do
            sleep 5
            echo "En attente de Prometheus..."
          done'

          # Vérification des targets
          TARGETS=$(curl -s "$PROMETHEUS_LOCAL/api/v1/targets")
          echo "Targets Prometheus:"
          echo "$TARGETS" | jq .

          # Vérification spécifique de l'exporter NGINX
          if ! echo "$TARGETS" | jq -e '.data.activeTargets[] | select(.labels.job=="nginx-exporter" and .health=="up")' >/dev/null; then
            echo "::error::Target NGINX exporter non trouvée ou inactive"
            exit 1
          fi

      # Configuration de Grafana
      - name: "📈 Configurer Grafana"
        env:
          GRAFANA_ADMIN_PASSWORD: rabaa123
        run: |
          GRAFANA_LOCAL="http://localhost:3000"
          echo "Configuration de Grafana sur $GRAFANA_LOCAL"

          # Attente que Grafana soit prêt
          timeout 60 bash -c 'until curl -sSf "$GRAFANA_LOCAL/api/health"; do
            sleep 5
            echo "En attente de Grafana..."
          done'

          # Configuration de la source de données Prometheus
          curl -X POST "$GRAFANA_LOCAL/api/datasources" \
            -H "Content-Type: application/json" \
            -u "admin:$GRAFANA_ADMIN_PASSWORD" \
            -d '{
              "name":"Prometheus",
              "type":"prometheus",
              "url":"http://prometheus:9090",
              "access":"proxy",
              "basicAuth":false
            }' || echo "La source de données existe peut-être déjà"

          # Vérification des dashboards
          DASHBOARDS=$(curl -s "$GRAFANA_LOCAL/api/search" -u "admin:$GRAFANA_ADMIN_PASSWORD")
          echo "Dashboards disponibles:"
          echo "$DASHBOARDS" | jq .

      # Génération du rapport de monitoring
      - name: "📝 Générer rapport de monitoring"
        working-directory: ./monitoring
        run: |
          echo "# Rapport de Monitoring" > report.md
          echo "## Services" >> report.md
          docker-compose ps >> report.md

          echo "## Métriques disponibles" >> report.md
          curl -s "http://localhost:9090/api/v1/label/__name__/values" | jq . >> report.md

          echo "## Dashboards Grafana" >> report.md
          curl -s "http://localhost:3000/api/search" -u "admin:$GRAFANA_ADMIN_PASSWORD" | jq '.[].title' >> report.md

          echo "::notice title=Rapport Monitoring::$(cat report.md)"

  # Job 5: Notifications finales
  notify:
    name: "5. Notifications Finales"
    needs: [docker-deploy, monitoring-deploy]
    runs-on: ubuntu-latest
    if: always()  # S'exécute même en cas d'échec
    
    steps:
      # Récupération de l'URL de production
      - name: "🌐 Récupérer l'URL de production"
        id: prod-url
        working-directory: ./infra
        run: |
          echo "PROD_URL=$(terraform -chdir=infra output -raw service_url)" >> $GITHUB_OUTPUT

      # Envoi du rapport par email
      - name: "📧 Envoyer rapport complet"
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          from: ${{ env.EMAIL_FROM }}
          to: ${{ env.YOUR_EMAIL }}
          subject: "Rapport de déploiement - ${{ github.repository }}"
          body: |
            Statut: ${{ job.status }}

            Détails :
            - Application: ${{ steps.prod-url.outputs.PROD_URL }}
            - Commit: ${{ github.sha }}
            - Date: $(date)
            - Logs: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}

            Monitoring:
            - Prometheus: http://localhost:9090
            - Grafana: http://localhost:3000
          attachments: ./monitoring/report.md