name: CI/CD - Pipeline DevOps complet

on:
  push:
    branches: [main]

env:
  # Configuration Kubernetes
  K3S_VERSION: v1.26.5+k3s1
  NAMESPACE: microservice-1
  DOCKER_REGISTRY: docker.io
  
  # Configuration Application
  APP_NAME: gestion-trajet
  DEPLOYMENT_NAME: gestion-trajet-app
  SERVICE_NAME: gestion-trajet-service
  CONTAINER_PORT: 8080
  SERVICE_PORT: 80
  DB_SERVICE_NAME: db-host
  
  # Configuration Monitoring
  PROMETHEUS_PORT: 9090
  GRAFANA_PORT: 3000
  
  # Configuration SonarQube
  SONAR_HOST_URL: http://localhost:9000
  
  # Configuration Email
  YOUR_EMAIL: elmbarkirabea@gmail.com
  EMAIL_FROM: "GitHub Actions <actions@github.com>"

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: üõéÔ∏è Checkout du code
        uses: actions/checkout@v3

      - name: üîë Connexion √† Docker Hub
        run: echo "${{ secrets.DOCKER_TOKEN }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: üî® Construire l'image Docker
        run: docker build -t ${{ secrets.DOCKER_USERNAME }}/gestion_trajet:latest .
          
      - name: üöÄ Pousser l'image sur Docker Hub
        run: docker push ${{ secrets.DOCKER_USERNAME }}/gestion_trajet:latest

  setup-and-test:
    name: "1. Installation et Tests"
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
      - name: "üõéÔ∏è Checkout du code"
        uses: actions/checkout@v4.1.1

      - name: "‚éî Configurer Node.js"
        uses: actions/setup-node@v3
        with:
          node-version: 20
          cache: 'npm'

      - name: "üì¶ Installer les d√©pendances"
        run: npm ci

      - name: "üß™ Tests Unitaires"
        run: npm run test:unit
        env:
          NODE_ENV: test

      - name: "üõ†Ô∏è Build de l'application"
        run: npm run build

  sonarqube-analysis:
    name: "2. Analyse SonarQube"
    needs: setup-and-test
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: "üõéÔ∏è Checkout du code"
        uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0

      - name: "üê≥ D√©marrer SonarQube"
        run: |
          docker run -d \
            --name sonarqube \
            -p 9000:9000 \
            -e SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true \
            sonarqube:9.9.1-community
          timeout 300 bash -c 'while ! curl -sSf ${{ env.SONAR_HOST_URL }}/api/system/status | grep -q "\"status\":\"UP\""; do
            sleep 10
            echo "En attente du d√©marrage..."
          done'

      - name: "üîë G√©n√©rer token SonarQube"
        run: |
          SONAR_TOKEN=$(curl -sS -u admin:admin \
            -X POST "${{ env.SONAR_HOST_URL }}/api/user_tokens/generate" \
            -d "name=github-action-$(date +%s)" \
            | jq -r '.token')
          echo "SONAR_TOKEN=$SONAR_TOKEN" >> $GITHUB_ENV
          echo "::add-mask::$SONAR_TOKEN"

      - name: "üîç Ex√©cuter analyse SonarQube"
        uses: SonarSource/sonarqube-scan-action@v4
        env:
          SONAR_TOKEN: ${{ env.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ env.SONAR_HOST_URL }}
        with:
          args: >
            -Dsonar.projectKey=gestion-trajet-app
            -Dsonar.sources=src
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info

      - name: "üßπ Nettoyer SonarQube"
        if: always()
        run: docker rm -f sonarqube || true

  kubernetes-deploy:
    name: "3. D√©ploiement Kubernetes"
    needs: sonarqube-analysis
    runs-on: ubuntu-latest
    steps:
      - name: "üõéÔ∏è Checkout du code"
        uses: actions/checkout@v4.1.1

      - name: "üñ•Ô∏è Installer K3s avec LoadBalancer"
        run: |
          curl -sfL https://get.k3s.io | INSTALL_K3S_VERSION=${{ env.K3S_VERSION }} sh -s - --disable metrics-server --disable traefik
          sudo mkdir -p /mnt/data/postgres
          sudo chmod 777 /mnt/data/postgres
          mkdir -p $HOME/.kube
          sudo cp /etc/rancher/k3s/k3s.yaml $HOME/.kube/config
          sudo chown $(id -u):$(id -g) $HOME/.kube/config
          kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml

      - name: "üöÄ D√©ployer l'application"
        run: |
          # Cr√©er le namespace
          kubectl create ns ${{ env.NAMESPACE }} || true
          
          # D√©ployer PostgreSQL
          kubectl apply -f k8s/postgres/ -n ${{ env.NAMESPACE }}
          
          # D√©ployer l'application avec LoadBalancer
          kubectl apply -f k8s/app/deployment.yaml -n ${{ env.NAMESPACE }}
          
          cat <<EOF | kubectl apply -n ${{ env.NAMESPACE }} -f -
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ env.SERVICE_NAME }}
          spec:
            type: LoadBalancer
            ports:
            - port: ${{ env.SERVICE_PORT }}
              targetPort: ${{ env.CONTAINER_PORT }}
            selector:
              app: ${{ env.APP_NAME }}
          EOF
          
          kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }} -n ${{ env.NAMESPACE }} --timeout=300s

      - name: "üîç Tester le d√©ploiement"
        run: |
          # Attendre que le LoadBalancer soit pr√™t
          sleep 30
          
          # R√©cup√©rer l'URL du service
          kubectl get svc ${{ env.SERVICE_NAME }} -n ${{ env.NAMESPACE }} -o wide
          
          # Test de sant√©
          SERVICE_IP=$(kubectl get svc ${{ env.SERVICE_NAME }} -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          if [ -z "$SERVICE_IP" ]; then
            SERVICE_IP="localhost"
            kubectl port-forward svc/${{ env.SERVICE_NAME }} ${{ env.SERVICE_PORT }}:${{ env.CONTAINER_PORT }} -n ${{ env.NAMESPACE }} >/dev/null 2>&1 &
            sleep 15
          fi
          
          if curl -sSf http://$SERVICE_IP:${{ env.SERVICE_PORT }}/health; then
            echo "‚úÖ Application accessible"
          else
            echo "‚ùå √âchec de connexion"
            kubectl logs -l app=${{ env.APP_NAME }} -n ${{ env.NAMESPACE }}
            exit 1
          fi

          monitoring-deploy:
            name: "4. D√©ploiement Monitoring"
            needs: docker-deploy
            runs-on: ubuntu-latest
            timeout-minutes: 30  # Augmentation du timeout global
            
            steps:
              - name: "üõéÔ∏è Checkout du code"
                uses: actions/checkout@v4.1.1
            
              - name: "üì¶ Installer Docker Compose"
                run: |
                  sudo curl -L "https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
                  sudo chmod +x /usr/local/bin/docker-compose
                  docker-compose --version
            
              - name: "üßπ Nettoyer l'environnement"
                working-directory: ./monitoring
                run: |
                  docker-compose down -v --remove-orphans || true
                  sudo rm -rf grafana-storage || true
                  mkdir -p grafana-storage
                  chmod -R 777 grafana-storage  # Assure les permissions
              - name: "üöÄ D√©marrer les services"
                working-directory: ./monitoring
                env:
                  GF_INSTALL_PLUGINS: ""  # D√©sactive les plugins par d√©faut
                run: |
                  docker-compose up -d
                  echo "Attente initiale (30s) pour l'initialisation..."
                  sleep 30
              - name: "üîç V√©rifier l'√©tat des conteneurs"
                working-directory: ./monitoring
                run: |
                  if docker-compose ps | grep -v "Up" | grep -q -v "STATUS"; then
                    echo "‚ùå Certains services ne sont pas d√©marr√©s:"
                    docker-compose ps
                    docker-compose logs
                    exit 1
                  fi
                  echo "‚úÖ Tous les services sont en cours d'ex√©cution"
              - name: "‚è≥ Attendre Grafana (version am√©lior√©e)"
                working-directory: ./monitoring
                run: |
                  echo "Attente du d√©marrage de Grafana..."
                  start_time=$(date +%s)
                  timeout=1200  # 20 minutes
                  
                  while :; do
                    # V√©rifier si le conteneur est en cours d'ex√©cution
                    if ! docker-compose ps | grep grafana | grep -q "Up"; then
                      echo "‚ùå Le conteneur Grafana s'est arr√™t√©"
                      docker-compose logs grafana
                      exit 1
                    fi
                    
                    # V√©rifier la sant√© via l'API
                    if curl -s http://localhost:3000/api/health | grep -q "\"database\":\"ok\""; then
                      echo "‚úÖ Grafana pr√™t apr√®s $(($(date +%s) - start_time)) secondes"
                      break
                    fi
                    
                    # V√©rifier aussi le endpoint de login
                    if curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/login | grep -q 200; then
                      echo "‚úÖ Grafana login page accessible apr√®s $(($(date +%s) - start_time)) secondes"
                      break
                    fi
                    
                    # Timeout
                    if [ $(($(date +%s) - start_time)) -ge $timeout ]; then
                      echo "‚ùå Timeout - Grafana n'a pas d√©marr√© apr√®s 20 minutes"
                      docker-compose logs grafana
                      exit 1
                    fi
                    
                    echo "En attente... ($(($(date +%s) - start_time))s)"
                    sleep 10
                  done
              - name: "üìà Configurer Grafana"
                working-directory: ./monitoring
                run: |
                  echo "Configuration de la source de donn√©es..."
                  for attempt in {1..5}; do
                    response=$(curl -s -o /dev/null -w "%{http_code}" \
                      -X POST "http://localhost:3000/api/datasources" \
                      -H "Content-Type: application/json" \
                      -u "admin:${{ env.GRAFANA_ADMIN_PASSWORD }}" \
                      -d '{
                        "name":"Prometheus",
                        "type":"prometheus",
                        "url":"http://prometheus:9090",
                        "access":"proxy",
                        "basicAuth":false
                      }')
                    
                    if [ "$response" -eq 200 ]; then
                      echo "‚úÖ Configuration r√©ussie"
                      exit 0
                    elif [ "$response" -eq 409 ]; then
                      echo "‚ÑπÔ∏è La source existe d√©j√†"
                      exit 0
                    else
                      echo "‚ö†Ô∏è √âchec tentative $attempt (HTTP $response)"
                      sleep 15
                    fi
                  done
                  echo "‚ùå √âchec apr√®s 5 tentatives"
                  exit 1
              - name: "üìù G√©n√©rer rapport"
                working-directory: ./monitoring
                run: |
                  echo "# Rapport de Monitoring" > report.md
                  echo "## √âtat des services" >> report.md
                  docker-compose ps >> report.md
                  echo "## M√©triques NGINX" >> report.md
                  curl -s http://localhost:9113/metrics | head -n 20 >> report.md
                  echo "## Targets Prometheus" >> report.md
                  curl -s http://localhost:9090/api/v1/targets | jq . >> report.md