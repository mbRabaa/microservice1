name: CI/CD - Docker Build & Deploy

on:
  push:
    branches:
      - main  # Le workflow s'exécutera lorsque des commits seront poussés sur la branche main

jobs:
  build-and-push:
    runs-on: self-hosted  # Utilise le self-hosted runner sur ta VM (local)

    steps:
      - name: 🛎️ Checkout du code
        uses: actions/checkout@v3  # Cette action récupère le code de ton dépôt GitHub

      # Connexion à Docker Hub avec l'authentification sécurisée
      - name: 🔑 Connexion à Docker Hub
        run: echo "${{ secrets.DOCKER_TOKEN }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: 🔨 Construire l'image Docker
        run: |
          docker build -t ${{ secrets.DOCKER_USERNAME }}/gestion_trajet:latest .  # Construction de l'image Docker

      - name: 🚀 Pousser l'image sur Docker Hub
        run: |
          docker push ${{ secrets.DOCKER_USERNAME }}/gestion_trajet:latest  # Poussée de l'image vers Docker Hub

  deploy:
    runs-on: self-hosted  # Utilisation du self-hosted runner pour déployer sur ta VM locale
    needs: build-and-push  # Le job 'deploy' sera exécuté après le job 'build-and-push'

    steps:
      - name: 🛎️ Checkout du code
        uses: actions/checkout@v3  # Récupération du code

      - name: 🔑 Connexion à Docker Hub
        run: echo "${{ secrets.DOCKER_TOKEN }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin  # Connexion sécurisée à Docker Hub

      - name: 🚢 Exécuter le conteneur Docker
        run: |
          docker pull ${{ secrets.DOCKER_USERNAME }}/gestion_trajet:latest  # Récupère la dernière image depuis Docker Hub
          docker rm -f mon-container || true  # Supprime l'ancien conteneur s'il existe déjà
          docker run -d --name mon-container -p 80:80 ${{ secrets.DOCKER_USERNAME }}/gestion_trajet:latest  # Exécution du conteneur avec l'image téléchargée
