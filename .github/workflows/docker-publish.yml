name: CI/CD - Pipeline DevOps complet + monitoring

on:
  push:
    branches: [main]

env:
  # Configuration Kubernetes
  K3S_VERSION: v1.26.5+k3s1
  NAMESPACE: microservice-1
  DOCKER_REGISTRY: docker.io
  
  # Configuration Application
  APP_NAME: gestion-trajet
  DEPLOYMENT_NAME: gestion-trajet-app
  SERVICE_NAME: gestion-trajet-service
  CONTAINER_PORT: 8080
  SERVICE_PORT: 80
  DB_SERVICE_NAME: db-host
  
  # Configuration Monitoring
  PROMETHEUS_PORT: 9090
  GRAFANA_PORT: 3000
  GRAFANA_ADMIN_PASSWORD: rabaa123
  
  # Configuration SonarQube
  SONAR_HOST_URL: http://localhost:9000
  
  # Configuration Email
  YOUR_EMAIL: elmbarkirabea@gmail.com
  EMAIL_FROM: "GitHub Actions <actions@github.com>"

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: üõéÔ∏è Checkout du code
        uses: actions/checkout@v3

      - name: üîë Connexion √† Docker Hub
        run: echo "${{ secrets.DOCKER_TOKEN }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: üî® Construire l'image Docker
        run: docker build -t ${{ secrets.DOCKER_USERNAME }}/gestion_trajet:latest .
          
      - name: üöÄ Pousser l'image sur Docker Hub
        run: docker push ${{ secrets.DOCKER_USERNAME }}/gestion_trajet:latest

  setup-and-test:
    name: "1. Installation et Tests"
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
      - name: "üõéÔ∏è Checkout du code"
        uses: actions/checkout@v4.1.1

      - name: "‚éî Configurer Node.js"
        uses: actions/setup-node@v3
        with:
          node-version: 20
          cache: 'npm'

      - name: "üì¶ Installer les d√©pendances"
        run: npm ci

      - name: "üß™ Tests Unitaires"
        run: npm run test:unit
        env:
          NODE_ENV: test

      - name: "üõ†Ô∏è Build de l'application"
        run: npm run build

  sonarqube-analysis:
    name: "2. Analyse SonarQube"
    needs: setup-and-test
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: "üõéÔ∏è Checkout du code"
        uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0

      - name: "üê≥ D√©marrer SonarQube"
        run: |
          docker run -d \
            --name sonarqube \
            -p 9000:9000 \
            -e SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true \
            sonarqube:9.9.1-community
          timeout 300 bash -c 'while ! curl -sSf ${{ env.SONAR_HOST_URL }}/api/system/status | grep -q "\"status\":\"UP\""; do
            sleep 10
            echo "En attente du d√©marrage..."
          done'

      - name: "üîë G√©n√©rer token SonarQube"
        run: |
          SONAR_TOKEN=$(curl -sS -u admin:admin \
            -X POST "${{ env.SONAR_HOST_URL }}/api/user_tokens/generate" \
            -d "name=github-action-$(date +%s)" \
            | jq -r '.token')
          echo "SONAR_TOKEN=$SONAR_TOKEN" >> $GITHUB_ENV
          echo "::add-mask::$SONAR_TOKEN"

      - name: "üîç Ex√©cuter analyse SonarQube"
        uses: SonarSource/sonarqube-scan-action@v4
        env:
          SONAR_TOKEN: ${{ env.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ env.SONAR_HOST_URL }}
        with:
          args: >
            -Dsonar.projectKey=gestion-trajet-app
            -Dsonar.sources=src
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info

      - name: "üßπ Nettoyer SonarQube"
        if: always()
        run: docker rm -f sonarqube || true

  kubernetes-deploy:
    name: "3. D√©ploiement Kubernetes"
    needs: sonarqube-analysis
    runs-on: ubuntu-latest
    steps:
      - name: "üõéÔ∏è Checkout du code"
        uses: actions/checkout@v4.1.1

      - name: "üñ•Ô∏è Installer K3s"
        run: |
          curl -sfL https://get.k3s.io | INSTALL_K3S_VERSION=${{ env.K3S_VERSION }} sh -s - --disable metrics-server --disable traefik
          sudo mkdir -p /mnt/data/postgres
          sudo chmod 777 /mnt/data/postgres
          mkdir -p $HOME/.kube
          sudo cp /etc/rancher/k3s/k3s.yaml $HOME/.kube/config
          sudo chown $(id -u):$(id -g) $HOME/.kube/config
          kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml

      - name: "üöÄ Initialiser le namespace"
        run: kubectl create ns ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: "üóÑÔ∏è Configurer le stockage PostgreSQL"
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: PersistentVolume
          metadata:
            name: postgres-pv
          spec:
            storageClassName: local-path
            capacity:
              storage: 5Gi
            accessModes:
              - ReadWriteOnce
            hostPath:
              path: /mnt/data/postgres
              type: DirectoryOrCreate
            persistentVolumeReclaimPolicy: Retain
          EOF
          
          cat <<EOF | kubectl apply -n ${{ env.NAMESPACE }} -f -
          apiVersion: v1
          kind: PersistentVolumeClaim
          metadata:
            name: postgres-pvc
          spec:
            storageClassName: local-path
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: 5Gi
            volumeName: postgres-pv
          EOF

      - name: "üîê Configurer les secrets PostgreSQL"
        run: |
          cat <<EOF | kubectl apply -n ${{ env.NAMESPACE }} -f -
          apiVersion: v1
          kind: Secret
          metadata:
            name: postgres-secret
          type: Opaque
          data:
            POSTGRES_PASSWORD: $(echo -n "securepassword" | base64 -w0)
            POSTGRES_USER: $(echo -n "postgres" | base64 -w0)
            POSTGRES_DB: $(echo -n "gestion_trajet" | base64 -w0)
          EOF

      - name: "üêò D√©ployer PostgreSQL et attendre qu'il soit pr√™t"
        run: |
          cat <<EOF | kubectl apply -n ${{ env.NAMESPACE }} -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: postgres
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: postgres
            template:
              metadata:
                labels:
                  app: postgres
              spec:
                containers:
                - name: postgres
                  image: postgres:13
                  ports:
                  - containerPort: 5432
                  envFrom:
                  - secretRef:
                      name: postgres-secret
                  volumeMounts:
                  - mountPath: /var/lib/postgresql/data
                    name: postgres-data
                volumes:
                - name: postgres-data
                  persistentVolumeClaim:
                    claimName: postgres-pvc
          EOF
          
          cat <<EOF | kubectl apply -n ${{ env.NAMESPACE }} -f -
          apiVersion: v1
          kind: Service
          metadata:
            name: db-host
          spec:
            selector:
              app: postgres
            ports:
              - protocol: TCP
                port: 5432
                targetPort: 5432
          EOF
          
          kubectl wait --for=condition=available --timeout=300s deployment/postgres -n ${{ env.NAMESPACE }}

      - name: "üöÄ D√©ployer l'application"
        run: |
          cat <<EOF | kubectl apply -n ${{ env.NAMESPACE }} -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ env.DEPLOYMENT_NAME }}
          spec:
            replicas: 3
            selector:
              matchLabels:
                app: ${{ env.APP_NAME }}
            template:
              metadata:
                labels:
                  app: ${{ env.APP_NAME }}
              spec:
                containers:
                - name: app
                  image: ${{ secrets.DOCKER_USERNAME }}/gestion_trajet:latest
                  ports:
                  - containerPort: ${{ env.CONTAINER_PORT }}
                  env:
                  - name: DB_HOST
                    value: "${{ env.DB_SERVICE_NAME }}"
                  - name: DB_PORT
                    value: "5432"
                  - name: DB_USER
                    valueFrom:
                      secretKeyRef:
                        name: postgres-secret
                        key: POSTGRES_USER
                  - name: DB_PASSWORD
                    valueFrom:
                      secretKeyRef:
                        name: postgres-secret
                        key: POSTGRES_PASSWORD
                  - name: DB_NAME
                    valueFrom:
                      secretKeyRef:
                        name: postgres-secret
                        key: POSTGRES_DB
          EOF
          
          cat <<EOF | kubectl apply -n ${{ env.NAMESPACE }} -f -
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ env.SERVICE_NAME }}
          spec:
            type: LoadBalancer
            ports:
            - port: ${{ env.SERVICE_PORT }}
              targetPort: ${{ env.CONTAINER_PORT }}
            selector:
              app: ${{ env.APP_NAME }}
          EOF

      - name: "‚è≥ Attendre que l'application soit pr√™te"
        run: |
          kubectl wait --for=condition=available --timeout=300s deployment/${{ env.DEPLOYMENT_NAME }} -n ${{ env.NAMESPACE }}

      - name: "‚úÖ V√©rifier le d√©ploiement"
        run: |
          kubectl get all -n ${{ env.NAMESPACE }}
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          kubectl get svc -n ${{ env.NAMESPACE }}

      - name: "üîÑ Rollback en cas d'√©chec"
        if: failure()
        run: |
          echo "=== D√©but du rollback ==="
          kubectl rollout undo deployment/${{ env.DEPLOYMENT_NAME }} -n ${{ env.NAMESPACE }}
          echo "=== √âtat apr√®s rollback ==="
          kubectl get pods -n ${{ env.NAMESPACE }}
          echo "=== Logs des pods ==="
          kubectl logs deployment/${{ env.DEPLOYMENT_NAME }} -n ${{ env.NAMESPACE }} --tail=50
          exit 1

      - name: "üìß Notification d'√©chec de d√©ploiement Kubernetes"
        if: failure()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: "√âchec du d√©ploiement Kubernetes - ${{ env.APP_NAME }}"
          from: ${{ env.EMAIL_FROM }}
          to: ${{ env.YOUR_EMAIL }}
          body: |
            Le d√©ploiement Kubernetes a √©chou√© et un rollback a √©t√© effectu√©.
            
            D√©tails :
            - Application: ${{ env.APP_NAME }}
            - Namespace: ${{ env.NAMESPACE }}
            - Commit: ${{ github.sha }}
            - Heure: $(date)
            
            Consultez les logs du workflow pour plus d'informations :
            ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

  monitoring-deploy:
    name: "4. D√©ploiement Monitoring"
    needs: kubernetes-deploy
    runs-on: ubuntu-latest
    env:
      GRAFANA_ADMIN_USER: admin
      GRAFANA_ADMIN_PASSWORD: rabaa123
    steps:
      - name: "üõéÔ∏è Checkout du code"
        uses: actions/checkout@v4
  
      - name: "üê≥ Pr√©-t√©l√©charger les images"
        run: |
          docker pull grafana/grafana:10.2.3
          docker pull prom/prometheus:latest
          docker pull prom/node-exporter:latest
  
      - name: "üê≥ Installer Docker Compose"
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
  
      - name: "üöÄ D√©marrer la stack de monitoring"
        working-directory: ./monitoring
        run: |
          # Nettoyer les anciens containers si existants
          docker-compose down || true
          
          # D√©marrer les services
          docker-compose up -d
          
          # Attendre que Grafana soit pr√™t avec un timeout plus long
          echo "En attente du d√©marrage de Grafana..."
          for i in {1..60}; do
            if curl -s http://localhost:3000/api/health | grep -q '"database":"ok"'; then
              echo "Grafana est pr√™t apr√®s $i essais"
              break
            fi
            sleep 5
            echo "Essai $i/60 - En attente..."
            if [ $i -eq 60 ]; then
              echo "ERREUR: Timeout - Grafana n'a pas d√©marr√© correctement apr√®s 5 minutes"
              echo "=== Logs Grafana ==="
              docker-compose logs grafana
              echo "=== Logs Prometheus ==="
              docker-compose logs prometheus
              exit 1
            fi
          done
  
      - name: "üìä Configurer Grafana"
        working-directory: ./monitoring
        run: |
          # V√©rification finale avant configuration
          if ! curl -s http://localhost:3000/api/health | grep -q '"database":"ok"'; then
            echo "ERREUR: Grafana n'est pas pr√™t pour la configuration"
            exit 1
          fi
          
          echo "Configuration de Grafana en cours..."
          
          # Configurer la source de donn√©es Prometheus
          echo "Ajout de la source de donn√©es Prometheus..."
          curl -X POST \
            -H "Content-Type: application/json" \
            -u "${{ env.GRAFANA_ADMIN_USER }}:${{ env.GRAFANA_ADMIN_PASSWORD }}" \
            -d '{
              "name":"Prometheus",
              "type":"prometheus",
              "url":"http://prometheus:9090",
              "access":"proxy",
              "isDefault":true
            }' \
            http://localhost:3000/api/datasources || echo "La source existe peut-√™tre d√©j√†"
          
          # V√©rifier que la source a √©t√© ajout√©e
          echo "V√©rification des sources de donn√©es..."
          curl -s -u "${{ env.GRAFANA_ADMIN_USER }}:${{ env.GRAFANA_ADMIN_PASSWORD }}" \
            http://localhost:3000/api/datasources | jq .
          
          # Importer les dashboards
          echo "Importation des dashboards..."
          for file in grafana-dashboards/*.json; do
            echo "Importation de $file"
            DASHBOARD=$(cat "$file" | jq 'del(.id)')
            curl -X POST \
              -H "Content-Type: application/json" \
              -u "${{ env.GRAFANA_ADMIN_USER }}:${{ env.GRAFANA_ADMIN_PASSWORD }}" \
              -d "$DASHBOARD" \
              http://localhost:3000/api/dashboards/db || echo "√âchec de l'importation du dashboard $file"
          done
          
          echo "Configuration termin√©e"

      - name: "üîÑ Rollback en cas d'√©chec"
        if: failure()
        run: |
          echo "=== Nettoyage des containers de monitoring ==="
          docker-compose down || true
          exit 1

      - name: "üìß Notification d'√©chec du monitoring"
        if: failure()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: "√âchec du d√©ploiement Monitoring - ${{ env.APP_NAME }}"
          from: ${{ env.EMAIL_FROM }}
          to: ${{ env.YOUR_EMAIL }}
          body: |
            Le d√©ploiement du monitoring a √©chou√©.
            
            D√©tails :
            - Application: ${{ env.APP_NAME }}
            - Heure: $(date)
            - Commit: ${{ github.sha }}
            
            Consultez les logs du workflow pour plus d'informations :
            ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      - name: "üìß Notification de succ√®s"
        if: success()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: "D√©ploiement r√©ussi - ${{ env.APP_NAME }}"
          from: ${{ env.EMAIL_FROM }}
          to: ${{ env.YOUR_EMAIL }}
          body: |
            Le pipeline CI/CD a √©t√© ex√©cut√© avec succ√®s !
            
            D√©tails :
            - Application: ${{ env.APP_NAME }}
            - Namespace: ${{ env.NAMESPACE }}
            - Monitoring:
              - Grafana: http://localhost:3000 (admin:${{ env.GRAFANA_ADMIN_PASSWORD }})
              - Prometheus: http://localhost:9090
            - Commit: ${{ github.sha }}
            - Heure: $(date)
            
            Acc√®s au workflow :
            ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}