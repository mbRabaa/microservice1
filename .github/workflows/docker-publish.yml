name: CI/CD - Pipeline DevOps complet

on:
  push:
    branches: [main]

env:
  # Configuration Kubernetes
  K3S_VERSION: v1.26.5+k3s1
  NAMESPACE: microservice-1
  DOCKER_REGISTRY: docker.io
  
  # Configuration Application
  APP_NAME: gestion-trajet
  DEPLOYMENT_NAME: gestion-trajet-app
  SERVICE_NAME: gestion-trajet-service
  CONTAINER_PORT: 8080
  SERVICE_PORT: 80
  DB_SERVICE_NAME: db-host
  
  # Configuration Monitoring
  PROMETHEUS_PORT: 9090
  GRAFANA_PORT: 3000
  
  # Configuration SonarQube
  SONAR_HOST_URL: http://localhost:9000
  
  # Configuration Email
  YOUR_EMAIL: elmbarkirabea@gmail.com
  EMAIL_FROM: "GitHub Actions <actions@github.com>"

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: ğŸ›ï¸ Checkout du code
        uses: actions/checkout@v3

      - name: ğŸ”‘ Connexion Ã  Docker Hub
        run: echo "${{ secrets.DOCKER_TOKEN }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: ğŸ”¨ Construire l'image Docker
        run: docker build -t ${{ secrets.DOCKER_USERNAME }}/gestion_trajet:latest .
          
      - name: ğŸš€ Pousser l'image sur Docker Hub
        run: docker push ${{ secrets.DOCKER_USERNAME }}/gestion_trajet:latest

  setup-and-test:
    name: "1. Installation et Tests"
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
      - name: "ğŸ›ï¸ Checkout du code"
        uses: actions/checkout@v4.1.1

      - name: "â” Configurer Node.js"
        uses: actions/setup-node@v3
        with:
          node-version: 20
          cache: 'npm'

      - name: "ğŸ“¦ Installer les dÃ©pendances"
        run: npm ci

      - name: "ğŸ§ª Tests Unitaires"
        run: npm run test:unit
        env:
          NODE_ENV: test

      - name: "ğŸ› ï¸ Build de l'application"
        run: npm run build

  sonarqube-analysis:
    name: "2. Analyse SonarQube"
    needs: setup-and-test
    runs-on: ubuntu-latest
    steps:
      - name: "ğŸ›ï¸ Checkout du code"
        uses: actions/checkout@v4.1.1

      - name: "ğŸ³ DÃ©marrer SonarQube"
        run: |
          docker run -d -p 9000:9000 --name sonarqube sonarqube:9.9.1-community
          sleep 60

      - name: "ğŸ” ExÃ©cuter analyse SonarQube"
        uses: SonarSource/sonarqube-scan-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: http://localhost:9000

  kubernetes-deploy:
    name: "3. DÃ©ploiement Kubernetes"
    needs: sonarqube-analysis
    runs-on: ubuntu-latest
    steps:
      - name: "ğŸ›ï¸ Checkout du code"
        uses: actions/checkout@v4.1.1

      - name: "ğŸ–¥ï¸ Installer K3s avec LoadBalancer"
        run: |
          curl -sfL https://get.k3s.io | INSTALL_K3S_VERSION=${{ env.K3S_VERSION }} sh -s - --disable metrics-server --disable traefik
          sudo mkdir -p /mnt/data/postgres
          sudo chmod 777 /mnt/data/postgres
          mkdir -p $HOME/.kube
          sudo cp /etc/rancher/k3s/k3s.yaml $HOME/.kube/config
          sudo chown $(id -u):$(id -g) $HOME/.kube/config
          kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml

      - name: "ğŸš€ DÃ©ployer l'application"
        run: |
          # CrÃ©er le namespace
          kubectl create ns ${{ env.NAMESPACE }} || true
          
          # DÃ©ployer PostgreSQL
          kubectl apply -f k8s/postgres/ -n ${{ env.NAMESPACE }}
          
          # DÃ©ployer l'application avec LoadBalancer
          kubectl apply -f k8s/app/deployment.yaml -n ${{ env.NAMESPACE }}
          
          cat <<EOF | kubectl apply -n ${{ env.NAMESPACE }} -f -
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ env.SERVICE_NAME }}
          spec:
            type: LoadBalancer
            ports:
            - port: ${{ env.SERVICE_PORT }}
              targetPort: ${{ env.CONTAINER_PORT }}
            selector:
              app: ${{ env.APP_NAME }}
          EOF
          
          kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }} -n ${{ env.NAMESPACE }} --timeout=300s

      - name: "ğŸ” Tester le dÃ©ploiement"
        run: |
          # Attendre que le LoadBalancer soit prÃªt
          sleep 30
          
          # RÃ©cupÃ©rer l'URL du service
          kubectl get svc ${{ env.SERVICE_NAME }} -n ${{ env.NAMESPACE }} -o wide
          
          # Test de santÃ©
          SERVICE_IP=$(kubectl get svc ${{ env.SERVICE_NAME }} -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          if [ -z "$SERVICE_IP" ]; then
            SERVICE_IP="localhost"
            kubectl port-forward svc/${{ env.SERVICE_NAME }} ${{ env.SERVICE_PORT }}:${{ env.CONTAINER_PORT }} -n ${{ env.NAMESPACE }} >/dev/null 2>&1 &
            sleep 15
          fi
          
          if curl -sSf http://$SERVICE_IP:${{ env.SERVICE_PORT }}/health; then
            echo "âœ… Application accessible"
          else
            echo "âŒ Ã‰chec de connexion"
            kubectl logs -l app=${{ env.APP_NAME }} -n ${{ env.NAMESPACE }}
            exit 1
          fi

  monitoring-deploy:
    name: "4. Monitoring"
    needs: kubernetes-deploy
    runs-on: ubuntu-latest
    steps:
      - name: "ğŸ›ï¸ Checkout du code"
        uses: actions/checkout@v4

      - name: "ğŸš€ DÃ©ployer Prometheus et Grafana"
        run: |
          kubectl apply -f k8s/monitoring/ -n ${{ env.NAMESPACE }}
          
          # Attendre que Grafana soit prÃªt
          kubectl wait --for=condition=available deployment/grafana -n ${{ env.NAMESPACE }} --timeout=300s
          
          # Configurer Grafana
          kubectl exec -n ${{ env.NAMESPACE }} deploy/grafana -- curl -X POST "http://localhost:3000/api/datasources" \
            -H "Content-Type: application/json" \
            -u "admin:${{ secrets.GRAFANA_ADMIN_PASSWORD }}" \
            -d '{"name":"Prometheus","type":"prometheus","url":"http://prometheus:9090","access":"proxy","isDefault":true}'