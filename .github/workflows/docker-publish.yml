name: CI/CD - Pipeline DevOps complet

on:
  push:
    branches: [main]

env:
  # Configuration Kubernetes
  K3S_VERSION: v1.26.5+k3s1
  NAMESPACE: microservice-1
  DOCKER_REGISTRY: docker.io
  
  # Configuration Application
  APP_NAME: gestion-trajet
  DEPLOYMENT_NAME: gestion-trajet-app
  SERVICE_NAME: gestion-trajet-service
  CONTAINER_PORT: 8080
  SERVICE_PORT: 80
  DB_SERVICE_NAME: db-host
  
  # Configuration Monitoring
  PROMETHEUS_PORT: 9090
  GRAFANA_PORT: 3000
  GRAFANA_ADMIN_PASSWORD: rabaa123
  
  # Configuration SonarQube
  SONAR_HOST_URL: http://localhost:9000
  
  # Configuration Email
  YOUR_EMAIL: elmbarkirabea@gmail.com
  EMAIL_FROM: "GitHub Actions <actions@github.com>"

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: üõéÔ∏è Checkout du code
        uses: actions/checkout@v3

      - name: üîë Connexion √† Docker Hub 
        run: echo "${{ secrets.DOCKER_TOKEN }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: üî® Construire l'image Docker
        run: |
          docker build -t ${{ secrets.DOCKER_USERNAME }}/gestion_trajet:latest .
          
      - name: üöÄ Pousser l'image sur Docker Hub
        run: |
          docker push ${{ secrets.DOCKER_USERNAME }}/gestion_trajet:latest

  setup-and-test:
    name: "1. Installation et Tests"
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
      - name: "üõéÔ∏è Checkout du code"
        uses: actions/checkout@v4.1.1

      - name: "‚éî Configurer Node.js"
        uses: actions/setup-node@v3
        with:
          node-version: 20
          cache: 'npm'

      - name: "üì¶ Installer les d√©pendances"
        run: npm ci

      - name: "üß™ Tests Unitaires"
        run: npm run test:unit
        env:
          NODE_ENV: test

      - name: "üîó Tests d'Int√©gration"
        run: npm run test:integration
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USER: testuser
          DB_PASSWORD: testpass
          NODE_ENV: test

      - name: "üõ†Ô∏è Build de l'application"
        run: npm run build

  sonarqube-analysis:
    name: "2. Analyse SonarQube"
    needs: setup-and-test
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: "üõéÔ∏è Checkout du code"
        uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0

      - name: "üê≥ D√©marrer SonarQube"
        run: |
          docker run -d \
            --name sonarqube \
            -p 9000:9000 \
            -e SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true \
            sonarqube:9.9.1-community
          timeout 300 bash -c 'while ! curl -sSf ${{ env.SONAR_HOST_URL }}/api/system/status | grep -q "\"status\":\"UP\""; do
            sleep 10
            echo "En attente du d√©marrage..."
          done'

      - name: "üîë G√©n√©rer token SonarQube"
        run: |
          SONAR_TOKEN=$(curl -sS -u admin:admin \
            -X POST "${{ env.SONAR_HOST_URL }}/api/user_tokens/generate" \
            -d "name=github-action-$(date +%s)" \
            | jq -r '.token')
          echo "SONAR_TOKEN=$SONAR_TOKEN" >> $GITHUB_ENV
          echo "::add-mask::$SONAR_TOKEN"

      - name: "üîç Ex√©cuter analyse SonarQube"
        uses: SonarSource/sonarqube-scan-action@v4
        env:
          SONAR_TOKEN: ${{ env.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ env.SONAR_HOST_URL }}
        with:
          args: >
            -Dsonar.projectKey=gestion-trajet-app
            -Dsonar.sources=src
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info

      - name: "üßπ Nettoyer SonarQube"
        if: always()
        run: docker rm -f sonarqube || true

  kubernetes-deploy:
    name: "3. D√©ploiement Kubernetes"
    needs: sonarqube-analysis
    runs-on: ubuntu-latest
    steps:
      - name: "üõéÔ∏è Checkout du code"
        uses: actions/checkout@v4.1.1

      - name: "üîê Login Docker Hub"
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: "üñ•Ô∏è Installer et configurer K3s"
        run: |
          # Installer K3s
          curl -sfL https://get.k3s.io | INSTALL_K3S_VERSION=${{ env.K3S_VERSION }} sh -
          
          # Configurer le stockage local
          sudo mkdir -p /mnt/data/postgres
          sudo chmod 777 /mnt/data/postgres
          
          # Configurer l'acc√®s kubectl
          mkdir -p $HOME/.kube
          sudo cp /etc/rancher/k3s/k3s.yaml $HOME/.kube/config
          sudo chown $(id -u):$(id -g) $HOME/.kube/config
          
          # Appliquer le provisioner de stockage local
          kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml

      - name: "üßπ Nettoyer avant d√©ploiement"
        run: |
          kubectl delete -f k8s/app/ --ignore-not-found=true -n ${{ env.NAMESPACE }} || true
          kubectl delete pvc postgres-pvc -n ${{ env.NAMESPACE }} --ignore-not-found=true || true
          kubectl delete pv postgres-pv --ignore-not-found=true || true

      - name: "üöÄ Initialiser le namespace"
        run: |
          kubectl create ns ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: "üóÑÔ∏è Configurer le stockage PostgreSQL"
        run: |
          # Cr√©er le PV manuel
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: PersistentVolume
          metadata:
            name: postgres-pv
          spec:
            storageClassName: local-path
            capacity:
              storage: 5Gi
            accessModes:
              - ReadWriteOnce
            hostPath:
              path: /mnt/data/postgres
              type: DirectoryOrCreate
            persistentVolumeReclaimPolicy: Retain
          EOF
          
          # Cr√©er le PVC avec r√©f√©rence explicite au PV
          cat <<EOF | kubectl apply -n ${{ env.NAMESPACE }} -f -
          apiVersion: v1
          kind: PersistentVolumeClaim
          metadata:
            name: postgres-pvc
          spec:
            storageClassName: local-path
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: 5Gi
            volumeName: postgres-pv
          EOF
          
          # V√©rification de la cr√©ation des ressources
          echo "=== PV cr√©√© ==="
          kubectl get pv postgres-pv -o wide
          echo "=== PVC cr√©√© ==="
          kubectl get pvc postgres-pvc -n ${{ env.NAMESPACE }} -o wide

      - name: "üîç V√©rifier le binding du PVC"
        run: |
          echo "=== Attente du binding du PVC ==="
          timeout 120s bash -c 'while [[ $(kubectl get pvc postgres-pvc -n ${{ env.NAMESPACE }} -o jsonpath="{.status.phase}") != "Bound" ]]; do
            sleep 5
            echo "Statut PVC: $(kubectl get pvc postgres-pvc -n ${{ env.NAMESPACE }} -o jsonpath="{.status.phase}")"
            echo "=== D√©tails PVC ==="
            kubectl describe pvc postgres-pvc -n ${{ env.NAMESPACE }}
          done'
          
          PVC_STATUS=$(kubectl get pvc postgres-pvc -n ${{ env.NAMESPACE }} -o jsonpath="{.status.phase}")
          if [ "$PVC_STATUS" != "Bound" ]; then
            echo "‚ùå √âchec du binding du PVC"
            echo "=== D√©tails du PVC ==="
            kubectl describe pvc postgres-pvc -n ${{ env.NAMESPACE }}
            echo "=== D√©tails du PV ==="
            kubectl describe pv postgres-pv
            echo "=== √âv√©nements ==="
            kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp'
            exit 1
          fi

      - name: "üîê Cr√©er les secrets et configmaps"
        run: |
            # Cr√©er la ConfigMap
            kubectl create configmap gestion-trajet-config \
              --from-literal=DB_NAME=gestion_trajet \
              -n ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
            
            # Cr√©er le Secret
            kubectl create secret generic gestion-trajet-secret \
              --from-literal=DB_USER=postgres \
              --from-literal=DB_PASSWORD=securepassword \
              -n ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -    

      - name: "üêò D√©ployer PostgreSQL"
        run: |
          # Appliquer les configurations PostgreSQL
          kubectl apply -f k8s/app/db/postgres-deployment.yaml -n ${{ env.NAMESPACE }}
          kubectl apply -f k8s/app/db/postgres-service.yaml -n ${{ env.NAMESPACE }}
          
          # Attendre que PostgreSQL soit pr√™t
          kubectl rollout status deployment/postgres -n ${{ env.NAMESPACE }} --timeout=300s

      - name: "üîç Valider la connexion PostgreSQL"
        run: |
          echo "=== Test de connexion PostgreSQL ==="
          POD_NAME=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=postgres -o jsonpath='{.items[0].metadata.name}')
          kubectl exec -n ${{ env.NAMESPACE }} $POD_NAME -- \
            pg_isready -U $(kubectl get secret gestion-trajet-secret -n ${{ env.NAMESPACE }} -o jsonpath='{.data.DB_USER}' | base64 --decode) \
            -h localhost -d $(kubectl get configmap gestion-trajet-config -n ${{ env.NAMESPACE }} -o jsonpath='{.data.DB_NAME}') --timeout=60 || {
              echo "‚ùå √âchec de connexion √† PostgreSQL"
              kubectl logs -n ${{ env.NAMESPACE }} $POD_NAME
              exit 1
            }

      - name: "üöÄ D√©ployer l'application"
        run: |
          kubectl apply -f k8s/app/deployment.yaml -n ${{ env.NAMESPACE }}
          kubectl apply -f k8s/app/service.yaml -n ${{ env.NAMESPACE }}
          kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }} -n ${{ env.NAMESPACE }} --timeout=300s

      - name: "üîç V√©rifier le d√©ploiement"
        run: |
          echo "=== Ressources d√©ploy√©es ==="
          kubectl get all -n ${{ env.NAMESPACE }}
          
          echo "=== D√©tails du d√©ploiement ==="
          kubectl describe deployment/${{ env.DEPLOYMENT_NAME }} -n ${{ env.NAMESPACE }}
          
          echo "=== Test de connectivit√© ==="
          kubectl port-forward svc/${{ env.SERVICE_NAME }} ${{ env.SERVICE_PORT }}:${{ env.CONTAINER_PORT }} -n ${{ env.NAMESPACE }} >/dev/null 2>&1 &
          sleep 10
          
          if curl -sSf http://localhost:${{ env.SERVICE_PORT }}/healthz; then
            echo "‚úÖ Application accessible"
          else
            echo "‚ùå √âchec de connexion"
            kubectl logs -l app=${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} --tail=50
            exit 1
          fi

  rollback-on-failure:
    name: "üîÑ Rollback Automatique"
    needs: [kubernetes-deploy]
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: "üîê Configurer l'acc√®s kubectl"
        run: |
          mkdir -p $HOME/.kube
          sudo cp /etc/rancher/k3s/k3s.yaml $HOME/.kube/config
          sudo chown $(id -u):$(id -g) $HOME/.kube/config

      - name: "‚è™ Ex√©cuter le rollback"
        run: |
          echo "=== Lancement du rollback ==="
          kubectl rollout undo deployment/${{ env.DEPLOYMENT_NAME }} -n ${{ env.NAMESPACE }}
          echo "=== √âtat apr√®s rollback ==="
          kubectl get pods -n ${{ env.NAMESPACE }}

      - name: "üìß Notification d'√©chec"
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          from: ${{ env.EMAIL_FROM }}
          to: ${{ env.YOUR_EMAIL }}
          subject: "√âchec de d√©ploiement - ${{ env.APP_NAME }}"
          body: |
            Le d√©ploiement a √©chou√©.
            
            D√©tails:
            - Commit: ${{ github.sha }}
            - Application: ${{ env.APP_NAME }}
            - Namespace: ${{ env.NAMESPACE }}
            - Heure: $(date)
            
            Un rollback a √©t√© effectu√©.

  # 5√®me job: D√©ploiement du monitoring
  monitoring-deploy:
    name: "4. D√©ploiement Monitoring"
    needs: kubernetes-deploy
    runs-on: ubuntu-latest
    env:
      PROMETHEUS_PORT: 9090
      GRAFANA_PORT: 3000
      NODEJS_PORT: 8081
      
    steps:
      - name: "üõéÔ∏è Checkout du code"
        uses: actions/checkout@v4

      - name: "üê≥ Installer Docker Compose"
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
      - name: "üßπ Nettoyer l'environnement"
        working-directory: ./monitoring
        run: docker-compose down -v --remove-orphans || true

      - name: "üöÄ D√©marrer le monitoring"
        working-directory: ./monitoring
        run: |
          docker-compose up -d --build
          echo "Attente du d√©marrage des services (30s)..."
          sleep 30
      - name: "üîç V√©rifier les services"
        working-directory: ./monitoring
        run: |
          if ! docker-compose ps | grep -q "Up"; then
            echo "‚ùå Certains services ne sont pas d√©marr√©s"
            docker-compose logs
            exit 1
          fi
          
          SERVICES=("nodejs-app:8080" "prometheus:9090" "grafana:3000")
          for service in "${SERVICES[@]}"; do
            if ! docker-compose ps | grep "$service" | grep -q "Up"; then
              echo "‚ùå Service $service non d√©marr√©"
              exit 1
            fi
          done
          echo "‚úÖ Tous les services sont op√©rationnels"
      - name: "üìä Configurer Grafana"
        working-directory: ./monitoring
        env:
          GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
        run: |
          until curl -s http://localhost:$GRAFANA_PORT/api/health; do
            echo "En attente de Grafana..."
            sleep 5
          done
          
          curl -X POST "http://localhost:$GRAFANA_PORT/api/datasources" \
            -H "Content-Type: application/json" \
            -u "admin:$GRAFANA_ADMIN_PASSWORD" \
            -d '{
              "name":"Prometheus",
              "type":"prometheus",
              "url":"http://prometheus:9090",
              "access":"proxy",
              "basicAuth":false,
              "isDefault":true
            }'
          
          echo "Configuration Grafana termin√©e"
      - name: "üß™ Tests de fonctionnement"
        run: |
          if ! curl -s http://localhost:$PROMETHEUS_PORT/-/ready | grep -q "Prometheus"; then
            echo "‚ùå Prometheus non pr√™t"
            exit 1
          fi
          
          if ! curl -s http://localhost:$NODEJS_PORT/metrics | grep -q "process_cpu_seconds_total"; then
            echo "‚ùå M√©triques Node.js non disponibles"
            exit 1
          fi
          
          if ! curl -s http://localhost:$GRAFANA_PORT/api/health | grep -q "\"database\":\"ok\""; then
            echo "‚ùå Grafana non pr√™t"
            exit 1
          fi
      - name: "üìù G√©n√©rer un rapport"
        working-directory: ./monitoring
        run: |
          echo "# Rapport de Monitoring" > monitoring-report.md
          echo "## √âtat des Services" >> monitoring-report.md
          docker-compose ps >> monitoring-report.md
          
          echo "## Cibles Prometheus" >> monitoring-report.md
          curl -s http://localhost:$PROMETHEUS_PORT/api/v1/targets | jq . >> monitoring-report.md
          
          echo "## M√©triques Node.js" >> monitoring-report.md
          curl -s http://localhost:$NODEJS_PORT/metrics | head -n 20 >> monitoring-report.md
          
          echo "Rapport g√©n√©r√© :"
          cat monitoring-report.md